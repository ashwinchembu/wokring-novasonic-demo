<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nova Sonic Voice Test - Node.js</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.95em;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }

        .status-indicator.connected {
            background: #28a745;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(220, 53, 69, 0.3);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
        }

        .recording {
            animation: recording-pulse 1s infinite;
        }

        @keyframes recording-pulse {
            0%, 100% { background: #dc3545; }
            50% { background: #ff6b7a; }
        }

        .transcript-area {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .transcript-entry {
            margin-bottom: 12px;
            padding: 10px;
            border-radius: 6px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .transcript-entry.user {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .transcript-entry.assistant {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
        }

        .transcript-entry.tool {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            font-size: 0.9em;
        }

        .speaker-label {
            font-weight: 600;
            margin-bottom: 5px;
            text-transform: uppercase;
            font-size: 0.85em;
        }

        .timestamp {
            font-size: 0.75em;
            opacity: 0.6;
            margin-left: 10px;
        }

        .hcp-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .hcp-item {
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .hcp-item:last-child {
            border-bottom: none;
        }

        .hcp-name {
            font-weight: 500;
        }

        .hcp-id {
            font-size: 0.85em;
            color: #666;
            font-family: monospace;
        }

        .info-box {
            background: #e7f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .info-box h3 {
            color: #0066cc;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .info-box ul {
            margin-left: 20px;
        }

        .info-box li {
            margin-bottom: 5px;
            color: #333;
        }

        .audio-visualizer {
            height: 60px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            padding: 10px;
        }

        .audio-bar {
            width: 4px;
            background: #667eea;
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .mode-btn {
            flex: 1;
            padding: 15px;
            font-size: 1.1em;
            background: #f8f9fa;
            color: #666;
            border: 2px solid #dee2e6;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .text-input-container {
            margin-top: 15px;
        }

        #textInput {
            width: 100%;
            padding: 12px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            font-family: inherit;
            font-size: 1em;
            resize: vertical;
        }

        #textInput:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: 700;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
        }

        .json-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            font-size: 0.95em;
        }

        .json-table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .json-table th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #ddd;
        }

        .json-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .json-table tbody tr:hover {
            background: #f8f9fa;
        }

        .json-table tbody tr:last-child td {
            border-bottom: none;
        }

        .field-name {
            font-weight: 600;
            color: #333;
            font-family: monospace;
        }

        .field-value {
            color: #666;
            word-break: break-word;
        }

        .field-value.empty {
            color: #ccc;
            font-style: italic;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .status-collected {
            background: #d4edda;
            color: #155724;
        }

        .status-missing {
            background: #fff3cd;
            color: #856404;
        }

        .status-required {
            background: #f8d7da;
            color: #721c24;
        }

        .nested-table {
            margin: 5px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 3px solid #667eea;
        }

        .nested-field {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 0.9em;
        }

        .nested-field-name {
            font-weight: 500;
            color: #555;
        }

        .nested-field-value {
            color: #777;
        }

        .history-table tbody tr {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .history-table tbody tr:hover {
            background: #e3f2fd !important;
            transform: scale(1.01);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .history-table .row-number {
            font-weight: 700;
            color: #667eea;
            font-size: 1.1em;
        }

        .history-table .timestamp {
            font-family: monospace;
            font-size: 0.9em;
            color: #666;
        }

        .status-complete {
            background: #d4edda;
            color: #155724;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .status-incomplete {
            background: #fff3cd;
            color: #856404;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .action-btn {
            padding: 4px 8px;
            margin: 0 2px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }

        .action-btn:hover {
            transform: scale(1.05);
        }

        .btn-view {
            background: #667eea;
            color: white;
        }

        .btn-download {
            background: #28a745;
            color: white;
        }

        .btn-delete {
            background: #dc3545;
            color: white;
        }

        /* Modal for viewing JSON */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            animation: fadeIn 0.3s;
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 0;
            border-radius: 15px;
            width: 80%;
            max-width: 900px;
            max-height: 80vh;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
            animation: slideDown 0.3s;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.5em;
        }

        .modal-close {
            color: white;
            font-size: 2em;
            font-weight: bold;
            cursor: pointer;
            border: none;
            background: none;
            padding: 0;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: rgba(255,255,255,0.2);
            transform: rotate(90deg);
        }

        .modal-body {
            padding: 30px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .json-display {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            word-break: break-word;
            color: #333;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .json-table {
                font-size: 0.85em;
            }

            .json-table th,
            .json-table td {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ AI Agent Test</h1>
            <p>Node.js/TypeScript Edition - Nova Sonic Voice</p>
        </div>

        <div class="main-content">
            <!-- Session Control -->
            <div class="card">
                <h2>üîß Session Control</h2>
                
                <div class="status">
                    <div class="status-indicator" id="connectionStatus"></div>
                    <span id="statusText">Not Connected</span>
                </div>

                <div class="info-box">
                    <h3>Session Info</h3>
                    <div id="sessionInfo">No active session</div>
                </div>

                <div class="button-group">
                    <button id="startSession" class="btn-primary">
                        ‚ñ∂Ô∏è Start Session
                    </button>
                    <button id="endSession" class="btn-danger" disabled>
                        ‚èπÔ∏è End Session
                    </button>
                </div>

                <!-- Voice Controls -->
                <div id="voiceControls">
                    <div class="audio-visualizer" id="visualizer">
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                    </div>

                    <div class="button-group">
                        <button id="startRecording" class="btn-success" disabled>
                            üéôÔ∏è Start Recording
                        </button>
                        <button id="stopRecording" class="btn-danger" disabled>
                            ‚è∏Ô∏è Stop Recording
                        </button>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-value" id="audioChunks">0</div>
                        <div class="stat-label">Audio Chunks</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="transcripts">0</div>
                        <div class="stat-label">Transcripts</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="audioResponses">0</div>
                        <div class="stat-label">Audio Resp.</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="toolCalls">0</div>
                        <div class="stat-label">Tool Calls</div>
                    </div>
                </div>
            </div>

            <!-- HCP List -->
            <div class="card">
                <h2>üë®‚Äç‚öïÔ∏è Healthcare Professionals</h2>
                <div class="info-box">
                    <h3>Available HCPs</h3>
                    <p>Say a doctor's name to test the lookup tool</p>
                </div>
                <div class="hcp-list" id="hcpList">
                    <p style="text-align: center; color: #666;">Loading...</p>
                </div>
            </div>

            <!-- Transcript Display -->
            <div class="card full-width">
                <h2>üí¨ Conversation Transcript</h2>
                <div class="transcript-area" id="transcriptArea">
                    <p style="text-align: center; color: #666;">
                        Start a session and begin recording to see the conversation here...
                    </p>
                </div>
                <button id="clearTranscript" class="btn-primary" style="width: 100%;">
                    üóëÔ∏è Clear Transcript
                </button>
            </div>

            <!-- Call Log JSON Table -->
            <div class="card full-width">
                <h2>üìä Call Log Data (Live)</h2>
                <div class="info-box">
                    <h3>Collected Information</h3>
                    <p>Watch as the AI extracts information during the conversation</p>
                </div>
                <div style="overflow-x: auto;">
                    <table class="json-table" id="callLogTable">
                        <thead>
                            <tr>
                                <th>Field</th>
                                <th>Value</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="callLogTableBody">
                            <tr>
                                <td colspan="3" style="text-align: center; color: #666; padding: 20px;">
                                    No data collected yet. Start a conversation to see information populate.
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div style="margin-top: 15px; display: flex; gap: 10px;">
                    <button id="exportJson" class="btn-primary" style="flex: 1;">
                        üíæ Save & Export JSON
                    </button>
                    <button id="clearCallLog" class="btn-danger" style="flex: 1;">
                        üóëÔ∏è Clear Current
                    </button>
                    <button id="testSaveBtn" class="btn-success" style="flex: 1;" onclick="testManualSave()">
                        üß™ Test Save
                    </button>
                </div>
            </div>

            <!-- Call History Table -->
            <div class="card full-width">
                <h2>üìö Call History</h2>
                <div class="info-box">
                    <h3>Saved Call Logs</h3>
                    <p>All exported calls appear here. Click any row to view full JSON.</p>
                </div>
                <div style="overflow-x: auto;">
                    <table class="json-table history-table" id="callHistoryTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Timestamp</th>
                                <th>HCP Name</th>
                                <th>Product</th>
                                <th>Date</th>
                                <th>Time</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="callHistoryTableBody">
                            <tr>
                                <td colspan="8" style="text-align: center; color: #666; padding: 20px;">
                                    No saved calls yet. Export your first call to see it here.
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div style="margin-top: 15px; display: flex; gap: 10px;">
                    <button id="refreshHistory" class="btn-success" style="flex: 1;">
                        üîÑ Refresh from Redshift
                    </button>
                    <button id="exportAllHistory" class="btn-primary" style="flex: 1;">
                        üì• Export All as JSON
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- JSON View Modal -->
    <div id="jsonModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üìã Call Log Details</h3>
                <button class="modal-close" onclick="closeJsonModal()">&times;</button>
            </div>
            <div class="modal-body">
                <pre id="jsonDisplay" class="json-display"></pre>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = 'http://localhost:8001';
        
        // State
        let sessionId = null;
        let bedrockSessionId = null; // Bedrock Agent Runtime session for call analysis
        let eventSource = null;
        let mediaRecorder = null;
        let audioContext = null;
        let isRecording = false;
        
        // Shared audio playback context and queue
        let playbackContext = null;
        let audioQueue = [];
        let isPlayingAudio = false;
        let nextStartTime = 0;
        let scheduledSources = [];
        
        // Call analysis state
        let transcriptBuffer = [];
        let hasAnalyzed = false;
        
        // Stats
        let stats = {
            audioChunks: 0,
            transcripts: 0,
            audioResponses: 0,
            toolCalls: 0
        };

        // Call log data tracking
        let callLogData = {
            call_channel: '',
            discussion_topic: '',
            status: '',
            account: '',
            id: '',
            adverse_event: false,
            adverse_event_details: null,
            noncompliance_event: false,
            noncompliance_description: '',
            call_notes: '',
            call_date: null,
            call_time: null,
            product: '',
            hcp_name: '',
            hcp_id: '',
            call_follow_up_task: {
                task_type: '',
                description: '',
                due_date: '',
                assigned_to: ''
            }
        };

        const requiredFields = ['hcp_name', 'call_date', 'call_time', 'product'];

        // Call history storage
        let callHistory = [];

        // DOM Elements
        const startSessionBtn = document.getElementById('startSession');
        const endSessionBtn = document.getElementById('endSession');
        const startRecordingBtn = document.getElementById('startRecording');
        const stopRecordingBtn = document.getElementById('stopRecording');
        const clearTranscriptBtn = document.getElementById('clearTranscript');
        const connectionStatus = document.getElementById('connectionStatus');
        const statusText = document.getElementById('statusText');
        const sessionInfo = document.getElementById('sessionInfo');
        const transcriptArea = document.getElementById('transcriptArea');
        const hcpList = document.getElementById('hcpList');
        const exportJsonBtn = document.getElementById('exportJson');
        const clearCallLogBtn = document.getElementById('clearCallLog');

        // Load HCP list
        async function loadHCPs() {
            try {
                const response = await fetch(`${API_BASE}/hcp/list`);
                const data = await response.json();
                
                hcpList.innerHTML = '';
                data.hcps.forEach(hcp => {
                    const item = document.createElement('div');
                    item.className = 'hcp-item';
                    item.innerHTML = `
                        <span class="hcp-name">${hcp.name}</span>
                        <span class="hcp-id">${hcp.id}</span>
                    `;
                    hcpList.appendChild(item);
                });
            } catch (error) {
                console.error('Failed to load HCPs:', error);
                hcpList.innerHTML = '<p style="color: red; text-align: center;">Failed to load HCPs</p>';
            }
        }

        // Start session
        async function startSession() {
            try {
                // Start Nova Sonic session
                const response = await fetch(`${API_BASE}/session/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                }
                
                const data = await response.json();
                sessionId = data.sessionId;
                
                // Establish Bedrock Agent Runtime session for call analysis
                try {
                    const bedrockResponse = await fetch(`${API_BASE}/api/session/establish`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userId: 'voice-user-' + Date.now() })
                    });
                    
                    if (bedrockResponse.ok) {
                        const bedrockData = await bedrockResponse.json();
                        bedrockSessionId = bedrockData.sessionId;
                        console.log('‚úÖ Bedrock session established:', bedrockSessionId);
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Failed to establish Bedrock session:', error);
                }
                
                updateStatus('connected', `Nova Sonic: ${sessionId.substring(0, 8)}...`);
                sessionInfo.innerHTML = `
                    <strong>Mode:</strong> Voice (Nova Sonic)<br>
                    <strong>Session ID:</strong> ${sessionId}<br>
                    <strong>Bedrock Session:</strong> ${bedrockSessionId ? bedrockSessionId.substring(0, 8) + '...' : 'Not available'}<br>
                    <strong>Status:</strong> ${data.status}<br>
                    <strong>Created:</strong> ${new Date(data.createdAt).toLocaleTimeString()}
                `;
                
                startSessionBtn.disabled = true;
                endSessionBtn.disabled = false;
                    startRecordingBtn.disabled = false;
                
                // Start SSE stream
                    startEventStream();
                
                addTranscript('system', '‚úÖ Nova Sonic session started successfully');
                if (bedrockSessionId) {
                    addTranscript('system', '‚úÖ Call recording analysis enabled');
                }
            } catch (error) {
                console.error('Failed to start session:', error);
                alert('Failed to start session: ' + error.message);
            }
        }

        // End session
        async function endSession() {
            try {
                    if (isRecording) {
                        stopRecording();
                    }
                    
                    if (eventSource) {
                        eventSource.close();
                        eventSource = null;
                    }
                    
                    // Cleanup audio playback
                    audioQueue = [];
                    isPlayingAudio = false;
                    nextStartTime = 0;
                    
                    scheduledSources.forEach(source => {
                        try { 
                            source.stop(); 
                            source.disconnect();
                        } catch (e) {
                            // Source may have already finished
                        }
                    });
                    scheduledSources = [];
                    
                    if (playbackContext) {
                        await playbackContext.close();
                        playbackContext = null;
                }
                
                if (sessionId) {
                    await fetch(`${API_BASE}/session/${sessionId}`, {
                        method: 'DELETE'
                    });
                }
                
                sessionId = null;
                bedrockSessionId = null;
                transcriptBuffer = [];
                hasAnalyzed = false;
                updateStatus('disconnected', 'Not Connected');
                sessionInfo.innerHTML = 'No active session';
                
                startSessionBtn.disabled = false;
                endSessionBtn.disabled = true;
                startRecordingBtn.disabled = true;
                stopRecordingBtn.disabled = true;
                
                addTranscript('system', '‚èπÔ∏è Session ended');
            } catch (error) {
                console.error('Failed to end session:', error);
            }
        }

        // Start event stream (SSE)
        function startEventStream() {
            if (!sessionId) return;
            
            eventSource = new EventSource(`${API_BASE}/events/stream/${sessionId}`);
            
            eventSource.addEventListener('transcript', (e) => {
                const data = JSON.parse(e.data);
                addTranscript(data.speaker, data.text, data.timestamp);
                parseTranscriptForData(data.text, data.speaker);
                updateStat('transcripts');
                
                // Buffer transcript for call analysis
                if (bedrockSessionId) {
                    transcriptBuffer.push({
                        speaker: data.speaker,
                        text: data.text,
                        timestamp: data.timestamp
                    });
                    
                    // Trigger analysis after collecting user utterances
                    if (data.speaker === 'user' && !hasAnalyzed) {
                        // Wait a bit for more context, then analyze
                        setTimeout(() => {
                            if (transcriptBuffer.length >= 2) {
                                analyzeCallRecording();
                            }
                        }, 3000);
                    }
                }
            });
            
            eventSource.addEventListener('audio', (e) => {
                const data = JSON.parse(e.data);
                playAudio(data.audioData);
                updateStat('audioResponses');
            });
            
            eventSource.addEventListener('tool_log', (e) => {
                const data = JSON.parse(e.data);
                if (data.type === 'tool_invocation') {
                    addTranscript('tool', `üîß Tool: ${data.toolName}\nInput: ${JSON.stringify(data.input, null, 2)}`);
                } else if (data.type === 'tool_result') {
                    addTranscript('tool', `‚úÖ Result: ${data.toolName}\n${JSON.stringify(data.result, null, 2)}`);
                    handleToolResult(data.toolName, data.result);
                }
                updateStat('toolCalls');
            });
            
            eventSource.addEventListener('error', (e) => {
                console.error('SSE error:', e);
                if (eventSource && eventSource.readyState === EventSource.CLOSED) {
                    addTranscript('system', '‚ùå Stream closed');
                }
            });
            
            eventSource.addEventListener('content_start', (e) => {
                const data = JSON.parse(e.data);
                console.log('Content start:', data.role);
            });
        }

        // Start recording
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000
                    } 
                });
                
                audioContext = new AudioContext({ sampleRate: 16000 });
                const source = audioContext.createMediaStreamSource(stream);
                const processor = audioContext.createScriptProcessor(4096, 1, 1);
                
                source.connect(processor);
                processor.connect(audioContext.destination);
                
                processor.onaudioprocess = async (e) => {
                    if (!isRecording) return;
                    
                    const audioData = e.inputBuffer.getChannelData(0);
                    const pcmData = new Int16Array(audioData.length);
                    
                    for (let i = 0; i < audioData.length; i++) {
                        pcmData[i] = Math.max(-32768, Math.min(32767, audioData[i] * 32768));
                    }
                    
                    const base64Audio = btoa(String.fromCharCode(...new Uint8Array(pcmData.buffer)));
                    
                    // Send to API
                    await fetch(`${API_BASE}/audio/chunk`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            sessionId: sessionId,
                            audioData: base64Audio,
                            format: 'pcm',
                            sampleRate: 16000,
                            channels: 1
                        })
                    });
                    
                    updateStat('audioChunks');
                    animateVisualizer(audioData);
                };
                
                isRecording = true;
                startRecordingBtn.disabled = true;
                stopRecordingBtn.disabled = false;
                startRecordingBtn.classList.add('recording');
                
                addTranscript('system', 'üéôÔ∏è Recording started');
            } catch (error) {
                console.error('Failed to start recording:', error);
                alert('Failed to start recording: ' + error.message);
            }
        }

        // Stop recording
        async function stopRecording() {
            try {
                isRecording = false;
                
                if (audioContext) {
                    await audioContext.close();
                    audioContext = null;
                }
                
                // Send audio end event
                await fetch(`${API_BASE}/audio/end`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: sessionId })
                });
                
                startRecordingBtn.disabled = false;
                stopRecordingBtn.disabled = true;
                startRecordingBtn.classList.remove('recording');
                
                addTranscript('system', '‚è∏Ô∏è Recording stopped');
            } catch (error) {
                console.error('Failed to stop recording:', error);
            }
        }

        // Initialize playback context (call once on first audio)
        function initPlaybackContext() {
            if (!playbackContext) {
                playbackContext = new AudioContext({ sampleRate: 24000 });
            }
            return playbackContext;
        }
        
        // Play audio response - matches working Python implementation
        async function playAudio(base64Audio) {
            // Add to queue
            audioQueue.push(base64Audio);
            
            // Start processing if not already playing
            if (!isPlayingAudio) {
                isPlayingAudio = true;
                const ctx = initPlaybackContext();
                nextStartTime = ctx.currentTime;
                processAudioQueue();
            }
        }
        
        // Process audio queue - matches Python's sequential processing
        async function processAudioQueue() {
            const ctx = playbackContext;
            if (!ctx) {
                console.error('Audio context not initialized');
                return;
            }
            
            // Process all chunks in queue
            while (audioQueue.length > 0) {
                const base64Audio = audioQueue.shift();
                
                try {
                    // Decode base64 to binary
                    const binaryString = atob(base64Audio);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    
                    // Convert to Int16Array (PCM data)
                    const int16Array = new Int16Array(bytes.buffer);
                    
                    // Create audio buffer
                    const audioBuffer = ctx.createBuffer(1, int16Array.length, 24000);
                    const channelData = audioBuffer.getChannelData(0);
                    
                    // Normalize PCM data with clamping (prevents distortion)
                    for (let i = 0; i < int16Array.length; i++) {
                        channelData[i] = Math.max(-1, Math.min(1, int16Array[i] / 32768.0));
                    }
                    
                    // Create source with gain node for volume control
                    const source = ctx.createBufferSource();
                    source.buffer = audioBuffer;
                    
                    const gainNode = ctx.createGain();
                    gainNode.gain.value = 1.0;
                    
                    source.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    // Schedule this chunk - if nextStartTime is in the past, play immediately
                    const playTime = Math.max(nextStartTime, ctx.currentTime);
                    source.start(playTime);
                    
                    // Update next play time (NO OVERLAP - just add duration exactly)
                    const bufferDuration = audioBuffer.duration;
                    nextStartTime = playTime + bufferDuration;
                    
                    console.log(`Scheduled audio: ${int16Array.length} samples at ${playTime.toFixed(3)}s, duration: ${bufferDuration.toFixed(3)}s, next: ${nextStartTime.toFixed(3)}s`);
                    
                    // Track source
                    scheduledSources.push(source);
                    
                    // If this is the last chunk, set up onended callback
                    if (audioQueue.length === 0) {
                        source.onended = () => {
                            // Remove from scheduled sources
                            const index = scheduledSources.indexOf(source);
                            if (index > -1) {
                                scheduledSources.splice(index, 1);
                            }
                            
                            // Wait a bit to see if more chunks arrive
                            setTimeout(() => {
                                if (audioQueue.length === 0) {
                                    isPlayingAudio = false;
                                    nextStartTime = 0;
                                    console.log('Audio playback complete');
                                } else {
                                    // More chunks arrived, continue processing
                                    processAudioQueue();
                                }
                            }, 50);
                        };
                    } else {
                        // Not last chunk, just track for cleanup
                        source.onended = () => {
                            const index = scheduledSources.indexOf(source);
                            if (index > -1) {
                                scheduledSources.splice(index, 1);
                            }
                        };
                    }
                    
                } catch (error) {
                    console.error('Error playing audio chunk:', error);
                }
                
                // Small delay between scheduling chunks
                if (audioQueue.length > 0) {
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
        }

        // Add transcript entry
        function addTranscript(speaker, text, timestamp = null) {
            const entry = document.createElement('div');
            entry.className = `transcript-entry ${speaker}`;
            
            const time = timestamp ? new Date(timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
            
            entry.innerHTML = `
                <div class="speaker-label">
                    ${speaker}
                    <span class="timestamp">${time}</span>
                </div>
                <div>${text}</div>
            `;
            
            transcriptArea.appendChild(entry);
            transcriptArea.scrollTop = transcriptArea.scrollHeight;
        }

        // Update status
        function updateStatus(status, text) {
            if (status === 'connected') {
                connectionStatus.classList.add('connected');
            } else {
                connectionStatus.classList.remove('connected');
            }
            statusText.textContent = text;
        }

        // Update stats
        function updateStat(stat) {
            stats[stat]++;
            document.getElementById(stat).textContent = stats[stat];
        }

        // Animate visualizer
        function animateVisualizer(audioData) {
            const bars = document.querySelectorAll('.audio-bar');
            const rms = Math.sqrt(audioData.reduce((sum, val) => sum + val * val, 0) / audioData.length);
            
            bars.forEach((bar, i) => {
                const height = Math.min(50, Math.max(5, rms * 500 + Math.random() * 10));
                bar.style.height = `${height}px`;
            });
        }

        // Update call log table
        function updateCallLogTable() {
            const tbody = document.getElementById('callLogTableBody');
            tbody.innerHTML = '';

            const fieldLabels = {
                hcp_name: 'HCP Name',
                hcp_id: 'HCP ID',
                call_date: 'Call Date',
                call_time: 'Call Time',
                product: 'Product',
                call_channel: 'Call Channel',
                discussion_topic: 'Discussion Topic',
                status: 'Status',
                account: 'Account',
                id: 'Record ID',
                call_notes: 'Call Notes',
                adverse_event: 'Adverse Event',
                adverse_event_details: 'AE Details',
                noncompliance_event: 'Noncompliance Event',
                noncompliance_description: 'Noncompliance Description'
            };

            // Main fields
            for (const [key, label] of Object.entries(fieldLabels)) {
                const value = callLogData[key];
                const hasValue = value !== null && value !== '' && value !== false;
                const isRequired = requiredFields.includes(key);
                
                let statusClass, statusText;
                if (hasValue) {
                    statusClass = 'status-collected';
                    statusText = '‚úì Collected';
                } else if (isRequired) {
                    statusClass = 'status-required';
                    statusText = '! Required';
                } else {
                    statusClass = 'status-missing';
                    statusText = '‚óã Empty';
                }

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="field-name">${label}</td>
                    <td class="field-value ${!hasValue ? 'empty' : ''}">
                        ${hasValue ? (typeof value === 'boolean' ? (value ? 'Yes' : 'No') : value) : '(not set)'}
                    </td>
                    <td><span class="status-badge ${statusClass}">${statusText}</span></td>
                `;
                tbody.appendChild(row);
            }

            // Follow-up task (nested)
            const task = callLogData.call_follow_up_task;
            const hasTask = task.task_type || task.description || task.due_date || task.assigned_to;
            
            const taskRow = document.createElement('tr');
            taskRow.innerHTML = `
                <td class="field-name">Follow-up Task</td>
                <td colspan="2">
                    ${hasTask ? `
                        <div class="nested-table">
                            <div class="nested-field">
                                <span class="nested-field-name">Task Type:</span>
                                <span class="nested-field-value">${task.task_type || '(not set)'}</span>
                            </div>
                            <div class="nested-field">
                                <span class="nested-field-name">Description:</span>
                                <span class="nested-field-value">${task.description || '(not set)'}</span>
                            </div>
                            <div class="nested-field">
                                <span class="nested-field-name">Due Date:</span>
                                <span class="nested-field-value">${task.due_date || '(not set)'}</span>
                            </div>
                            <div class="nested-field">
                                <span class="nested-field-name">Assigned To:</span>
                                <span class="nested-field-value">${task.assigned_to || '(not set)'}</span>
                            </div>
                        </div>
                    ` : '<span class="field-value empty">(no follow-up task)</span>'}
                </td>
            `;
            tbody.appendChild(taskRow);
        }

        // Parse transcript for data extraction
        function parseTranscriptForData(text, speaker) {
            if (speaker !== 'assistant') return;

            let dataUpdated = false;

            // Look for HCP name mentions
            const hcpMatch = text.match(/(?:found|identified|confirmed)\s+(?:Dr\.|Doctor)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/i);
            if (hcpMatch && !callLogData.hcp_name) {
                callLogData.hcp_name = 'Dr. ' + hcpMatch[1];
                dataUpdated = true;
                console.log('‚úÖ Extracted HCP name from text:', callLogData.hcp_name);
                updateCallLogTable();
            }

            // Look for dates
            const dateMatch = text.match(/\b(\d{4}-\d{2}-\d{2}|\d{1,2}\/\d{1,2}\/\d{2,4}|today|yesterday)\b/i);
            if (dateMatch && !callLogData.call_date) {
                callLogData.call_date = dateMatch[1];
                dataUpdated = true;
                console.log('‚úÖ Extracted date from text:', callLogData.call_date);
                updateCallLogTable();
            }

            // Look for time
            const timeMatch = text.match(/\b(\d{1,2}:\d{2}\s*(?:AM|PM)?)\b/i);
            if (timeMatch && !callLogData.call_time) {
                callLogData.call_time = timeMatch[1];
                dataUpdated = true;
                console.log('‚úÖ Extracted time from text:', callLogData.call_time);
                updateCallLogTable();
            }

            // Look for product mentions (improved patterns)
            const productPatterns = [
                // "product is X" or "medication is X"
                /(?:product|medication|drug|treatment)\s+(?:is|was)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i,
                // "discussed X" or "about X" (capturing capitalized words only)
                /(?:discussed|about)\s+([A-Z][a-z]{3,}(?:\s+[A-Z][a-z]+)?)/,
                // "Product: X" or "Medication: X"
                /(?:product|medication|drug|treatment):\s*([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i
            ];
            
            for (const pattern of productPatterns) {
                const match = text.match(pattern);
                if (match && !callLogData.product) {
                    // Clean up the product name (remove common filler words)
                    let productName = match[1].trim();
                    // Remove words like "was", "is", "discussed", etc.
                    productName = productName.replace(/^(was|is|discussed|about|the)\s+/gi, '');
                    
                    if (productName.length > 2) {
                        callLogData.product = productName;
                        dataUpdated = true;
                        console.log('‚úÖ Extracted product from text:', callLogData.product);
                        updateCallLogTable();
                        break;
                    }
                }
            }

            // Check if we should auto-save after parsing
            if (dataUpdated) {
                checkAutoSave();
            }
        }

        // Handle tool results for data extraction
        function handleToolResult(toolName, result) {
            console.log('üîß handleToolResult:', toolName, result);
            
            let dataUpdated = false;
            
            if (toolName === 'lookupHcpTool' && result.found) {
                if (result.name && !callLogData.hcp_name) {
                    callLogData.hcp_name = result.name;
                    dataUpdated = true;
                    console.log('‚úÖ Updated hcp_name:', result.name);
                }
                if (result.hcp_id && !callLogData.hcp_id) {
                    callLogData.hcp_id = result.hcp_id;
                    dataUpdated = true;
                    console.log('‚úÖ Updated hcp_id:', result.hcp_id);
                }
                if (result.hco_name && !callLogData.account) {
                    callLogData.account = result.hco_name;
                    dataUpdated = true;
                    console.log('‚úÖ Updated account:', result.hco_name);
                }
                updateCallLogTable();
            } else if (toolName === 'getDateTool') {
                if (result.date && !callLogData.call_date) {
                    callLogData.call_date = result.date;
                    dataUpdated = true;
                    console.log('‚úÖ Updated call_date:', result.date);
                }
                if (result.time && !callLogData.call_time) {
                    callLogData.call_time = result.time;
                    dataUpdated = true;
                    console.log('‚úÖ Updated call_time:', result.time);
                }
                updateCallLogTable();
            } else if (toolName === 'insertCallTool') {
                // When AI persists the call to Redshift, save to local history
                if (result.ok) {
                    console.log('üéØ insertCallTool succeeded! Auto-saving to history...');
                    
                    // Cancel any pending auto-save timeout
                    if (window.autoSaveTimeout) {
                        clearTimeout(window.autoSaveTimeout);
                        window.autoSaveTimeout = null;
                    }
                    
                    // Immediately save to history
                    autoSaveCallLog();
                            } else {
                    console.log('‚ö†Ô∏è  insertCallTool failed:', result.error);
                }
                return; // Don't check auto-save, we already handled it
            }
            
            // Check if we should auto-save
            if (dataUpdated) {
                checkAutoSave();
            }
        }
        
        // Check if all required fields are collected and auto-save
        function checkAutoSave() {
            const hasAllRequired = requiredFields.every(field => {
                const value = callLogData[field];
                return value && value !== '' && value !== null;
            });
            
            if (hasAllRequired) {
                console.log('üéØ All required fields collected!', {
                    hcp_name: callLogData.hcp_name,
                    call_date: callLogData.call_date,
                    call_time: callLogData.call_time,
                    product: callLogData.product
                });
                
                // Auto-save after a short delay (to allow for more data collection)
                if (!window.autoSaveTimeout) {
                    console.log('‚è±Ô∏è  Auto-save scheduled in 5 seconds...');
                    window.autoSaveTimeout = setTimeout(() => {
                        autoSaveCallLog();
                        window.autoSaveTimeout = null;
                    }, 5000);
                }
            } else {
                const missing = requiredFields.filter(field => {
                    const value = callLogData[field];
                    return !value || value === '' || value === null;
                });
                console.log('‚ö†Ô∏è  Missing required fields:', missing);
            }
        }
        
        // Auto-save call log
        function autoSaveCallLog() {
            console.log('üíæ AUTO-SAVING call log...');
            
            // Check if we already saved this data
            const lastSaved = callHistory.length > 0 ? callHistory[callHistory.length - 1] : null;
            if (lastSaved && lastSaved.session_id === sessionId) {
                console.log('‚ÑπÔ∏è  Call already saved for this session, skipping auto-save');
                return;
            }
            
            // Create a copy with timestamp
            const callLogCopy = {
                ...callLogData,
                exported_at: new Date().toISOString(),
                session_id: sessionId,
                auto_saved: true
            };

            // Add to history
            callHistory.push(callLogCopy);
            console.log('‚úÖ Auto-saved to history. Total calls:', callHistory.length);
            
            // Update history table
            updateCallHistoryTable();
            
            // Save to localStorage
            saveHistoryToLocalStorage();
            
            // Show notification in transcript
            addTranscript('system', `üíæ Call log #${callHistory.length} auto-saved! (All required fields collected)`);
            
            // Show visual notification
            showNotification('Call Log Auto-Saved!', 'success');
        }
        
        // Show notification banner
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 25px;
                background: ${type === 'success' ? '#28a745' : '#667eea'};
                color: white;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: 600;
                animation: slideInRight 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Export JSON and save to history
        function exportCallLogJson() {
            console.log('üì• exportCallLogJson called');
            console.log('Current callLogData:', callLogData);
            console.log('Current callHistory length:', callHistory.length);
            
            // Create a copy with timestamp
            const callLogCopy = {
                ...callLogData,
                exported_at: new Date().toISOString(),
                session_id: sessionId
            };

            console.log('Call log copy created:', callLogCopy);

            // Add to history
            callHistory.push(callLogCopy);
            console.log('Added to history. New length:', callHistory.length);
            
            // Update history table
            updateCallHistoryTable();
            console.log('History table updated');
            
            // Download JSON file
            const jsonStr = JSON.stringify(callLogCopy, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
            a.download = `call-log-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log('JSON file downloaded');
            
            addTranscript('system', `üíæ Call log #${callHistory.length} saved and exported`);
            
            // Save to localStorage
            saveHistoryToLocalStorage();
            console.log('‚úÖ Saved to localStorage');
            console.log('Verification - localStorage has:', localStorage.getItem('callHistory') ? 'data' : 'nothing');
        }

        // Clear call log
        function clearCallLogData() {
            callLogData = {
                call_channel: '',
                discussion_topic: '',
                status: '',
                account: '',
                id: '',
                adverse_event: false,
                adverse_event_details: null,
                noncompliance_event: false,
                noncompliance_description: '',
                call_notes: '',
                call_date: null,
                call_time: null,
                product: '',
                hcp_name: '',
                hcp_id: '',
                call_follow_up_task: {
                    task_type: '',
                    description: '',
                    due_date: '',
                    assigned_to: ''
                }
            };
            updateCallLogTable();
            addTranscript('system', 'üóëÔ∏è Call log data cleared');
        }

        // Update call history table
        function updateCallHistoryTable() {
            const tbody = document.getElementById('callHistoryTableBody');
            
            if (callHistory.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="8" style="text-align: center; color: #666; padding: 20px;">
                            No saved calls yet. Calls from Redshift will appear here.
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = '';
            
            callHistory.forEach((log, index) => {
                const hasAllRequired = requiredFields.every(field => log[field]);
                const statusClass = hasAllRequired ? 'status-complete' : 'status-incomplete';
                const statusText = hasAllRequired ? '‚úì Complete' : '‚ö† Incomplete';
                
                const timestamp = new Date(log.created_at || log.exported_at || Date.now()).toLocaleString();
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="row-number">${index + 1}</td>
                    <td class="timestamp">${timestamp}</td>
                    <td>${log.hcp_name || '(not set)'}</td>
                    <td>${log.product || '(not set)'}</td>
                    <td>${log.call_date || '(not set)'}</td>
                    <td>${log.call_time || '(not set)'}</td>
                    <td><span class="${statusClass}">${statusText}</span></td>
                    <td>
                        <button class="action-btn btn-view" onclick="viewCallLog(${index})" title="View JSON">üëÅÔ∏è</button>
                        <button class="action-btn btn-download" onclick="downloadSingleLog(${index})" title="Download">üíæ</button>
                        <button class="action-btn btn-delete" onclick="deleteFromHistory(${index})" title="Delete">üóëÔ∏è</button>
                    </td>
                `;
                
                // Make row clickable (except action buttons)
                row.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('action-btn')) {
                        viewCallLog(index);
                    }
                });
                
                tbody.appendChild(row);
            });
        }

        // View call log in modal
        function viewCallLog(index) {
            const log = callHistory[index];
            const jsonDisplay = document.getElementById('jsonDisplay');
            jsonDisplay.textContent = JSON.stringify(log, null, 2);
            
            const modal = document.getElementById('jsonModal');
            modal.style.display = 'block';
        }

        // Close JSON modal
        function closeJsonModal() {
            const modal = document.getElementById('jsonModal');
            modal.style.display = 'none';
        }

        // Download single log
        function downloadSingleLog(index) {
            const log = callHistory[index];
            const jsonStr = JSON.stringify(log, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date(log.exported_at).toISOString().replace(/[:.]/g, '-').substring(0, 19);
            a.download = `call-log-${index + 1}-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Delete from history
        function deleteFromHistory(index) {
            if (confirm(`Delete call log #${index + 1}?`)) {
                callHistory.splice(index, 1);
                updateCallHistoryTable();
                saveHistoryToLocalStorage();
                addTranscript('system', `üóëÔ∏è Call log #${index + 1} deleted from history`);
            }
        }

        // Export all history as single JSON file
        function exportAllHistory() {
            if (callHistory.length === 0) {
                alert('No call history to export');
                return;
            }
            
            const jsonStr = JSON.stringify(callHistory, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
            a.download = `call-history-all-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            addTranscript('system', `üì• Exported ${callHistory.length} call logs`);
        }

        // Clear all history
        function clearAllHistory() {
            if (callHistory.length === 0) {
                alert('No history to clear');
                return;
            }
            
            if (confirm(`Delete all ${callHistory.length} call logs from history?`)) {
                callHistory = [];
                updateCallHistoryTable();
                saveHistoryToLocalStorage();
                addTranscript('system', 'üóëÔ∏è All call history cleared');
            }
        }

        // Save history to localStorage
        function saveHistoryToLocalStorage() {
            try {
                const dataToSave = JSON.stringify(callHistory);
                localStorage.setItem('callHistory', dataToSave);
                console.log(`üíæ Saved ${callHistory.length} calls to localStorage (${dataToSave.length} bytes)`);
            } catch (e) {
                console.error('‚ùå Failed to save history to localStorage:', e);
                alert('Failed to save history to localStorage: ' + e.message);
            }
        }

        // Load history from Redshift
        async function loadHistoryFromRedshift() {
            try {
                console.log('üîÑ Loading call history from Redshift...');
                
                const response = await fetch(`${API_BASE}/api/calls/history`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.calls && Array.isArray(data.calls)) {
                    callHistory = data.calls.map(call => ({
                        call_pk: call.call_pk,
                        hcp_name: call.id, // This is the HCP ID from Redshift
                        hcp_id: call.id,
                        account: call.account,
                        product: call.product,
                        call_date: call.call_date ? new Date(call.call_date).toISOString().split('T')[0] : null,
                        call_time: call.call_time,
                        call_channel: call.call_channel,
                        discussion_topic: call.discussion_topic,
                        status: call.status,
                        adverse_event: call.adverse_event,
                        noncompliance_event: call.noncompliance_event,
                        call_notes: call.call_notes,
                        followup_task_type: call.followup_task_type,
                        created_at: call.created_at,
                        source: 'redshift'
                    }));
                    
                    updateCallHistoryTable();
                    console.log(`‚úÖ Loaded ${callHistory.length} call logs from Redshift`);
                    addTranscript('system', `üìä Loaded ${callHistory.length} calls from Redshift`);
                    return callHistory.length;
                } else {
                    console.log('‚ÑπÔ∏è  No calls found in Redshift');
                    callHistory = [];
                    updateCallHistoryTable();
                    return 0;
                }
            } catch (e) {
                console.error('‚ùå Failed to load history from Redshift:', e);
                addTranscript('system', `‚ö†Ô∏è  Failed to load Redshift history: ${e.message}`);
                return 0;
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('jsonModal');
            if (event.target === modal) {
                closeJsonModal();
            }
        }

        // Analyze call recording using Bedrock session
        async function analyzeCallRecording() {
            if (!bedrockSessionId || hasAnalyzed) return;
            
            try {
                console.log('üîç Analyzing call recording...');
                
                // Combine transcripts into a single text
                const combinedText = transcriptBuffer
                    .map(t => `${t.speaker}: ${t.text}`)
                    .join('\n');
                
                console.log('Combined transcript:', combinedText);
                
                const response = await fetch(`${API_BASE}/api/call/analyze`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: bedrockSessionId,
                        input: combinedText
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                }
                
                const result = await response.json();
                console.log('‚úÖ Call analysis result:', result);
                
                hasAnalyzed = true;
                
                // Update call log data with analyzed results
                if (result.callRecordingPayload) {
                    const payload = result.callRecordingPayload;
                    
                    callLogData.accountName = payload.accountName || callLogData.hcp_name;
                    callLogData.hcp_name = payload.accountName || callLogData.hcp_name;
                    callLogData.hcp_id = payload.accountId || callLogData.hcp_id;
                    callLogData.call_date = payload.call_date || callLogData.call_date;
                    callLogData.call_time = payload.call_time || callLogData.call_time;
                    callLogData.product = payload.product_description || callLogData.product;
                    callLogData.call_channel = payload.call_channel || callLogData.call_channel;
                    callLogData.discussion_topic = payload.discussion_notes || callLogData.discussion_topic;
                    callLogData.call_notes = payload.call_notes || callLogData.call_notes;
                    callLogData.adverse_event = payload.adverse_event || callLogData.adverse_event;
                    callLogData.adverse_event_details = payload.adverse_event_details || callLogData.adverse_event_details;
                    callLogData.noncompliance_event = payload.non_compliance_event || callLogData.noncompliance_event;
                    callLogData.noncompliance_description = payload.non_compliance_description || callLogData.noncompliance_description;
                    
                    updateCallLogTable();
                    
                    addTranscript('system', 'ü§ñ AI analyzed call recording and extracted data');
                    
                    // Check for missing information
                    if (result.missingInformationEvents && result.missingInformationEvents.length > 0) {
                        console.log('‚ö†Ô∏è Missing information:', result.missingInformationEvents);
                        addTranscript('system', `‚ö†Ô∏è Missing: ${result.missingInformationEvents.join(', ')}`);
                        
                        // Check if we should auto-save
                        checkAutoSave();
                    } else {
                        console.log('‚úÖ All required information collected');
                        addTranscript('system', '‚úÖ All required information collected');
                        checkAutoSave();
                    }
                }
            } catch (error) {
                console.error('‚ùå Failed to analyze call recording:', error);
                addTranscript('system', `‚ùå Analysis failed: ${error.message}`);
            }
        }
        
        // Fill missing details in call recording
        async function fillMissingDetails(inputText) {
            if (!bedrockSessionId) return;
            
            try {
                console.log('üîç Filling missing details...');
                
                const response = await fetch(`${API_BASE}/api/call/fill-missing`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: bedrockSessionId,
                        input: inputText
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                }
                
                const result = await response.json();
                console.log('‚úÖ Fill missing result:', result);
                
                // Update call log data with filled results
                if (result.callRecordingPayload) {
                    const payload = result.callRecordingPayload;
                    
                    if (payload.accountName) callLogData.hcp_name = payload.accountName;
                    if (payload.accountId) callLogData.hcp_id = payload.accountId;
                    if (payload.call_date) callLogData.call_date = payload.call_date;
                    if (payload.call_time) callLogData.call_time = payload.call_time;
                    if (payload.product_description) callLogData.product = payload.product_description;
                    
                    updateCallLogTable();
                    
                    addTranscript('system', '‚úÖ Updated with missing information');
                    
                    // Check if we should auto-save
                    checkAutoSave();
                }
            } catch (error) {
                console.error('‚ùå Failed to fill missing details:', error);
            }
        }
        
        // Test manual save function
        function testManualSave() {
            console.log('üß™ TEST SAVE CALLED');
            
            const testCall = {
                hcp_name: 'Dr. Test ' + new Date().getTime(),
                hcp_id: 'TEST-' + Date.now(),
                call_date: new Date().toISOString().split('T')[0],
                call_time: new Date().toTimeString().split(' ')[0],
                product: 'Test Product',
                exported_at: new Date().toISOString(),
                session_id: 'test-session',
                test: true
            };
            
            console.log('Test call object:', testCall);
            
            callHistory.push(testCall);
            console.log('Added to history. Length:', callHistory.length);
            
            updateCallHistoryTable();
            console.log('Table updated');
            
            saveHistoryToLocalStorage();
            console.log('Saved to localStorage');
            
            // Verify
            const verify = localStorage.getItem('callHistory');
            console.log('Verification:', verify ? `${verify.length} bytes in localStorage` : 'NOTHING in localStorage!');
            
            addTranscript('system', `üß™ Test call #${callHistory.length} added to history`);
            alert(`Test call added! Total calls: ${callHistory.length}`);
        }

        // Event listeners
        startSessionBtn.addEventListener('click', startSession);
        endSessionBtn.addEventListener('click', endSession);
        startRecordingBtn.addEventListener('click', startRecording);
        stopRecordingBtn.addEventListener('click', stopRecording);
        clearTranscriptBtn.addEventListener('click', () => {
            transcriptArea.innerHTML = '<p style="text-align: center; color: #666;">Transcript cleared</p>';
            stats = { audioChunks: 0, transcripts: 0, audioResponses: 0, toolCalls: 0 };
            Object.keys(stats).forEach(key => {
                document.getElementById(key).textContent = '0';
            });
        });
        exportJsonBtn.addEventListener('click', exportCallLogJson);
        clearCallLogBtn.addEventListener('click', clearCallLogData);
        
        // History buttons
        document.getElementById('refreshHistory').addEventListener('click', () => {
            addTranscript('system', 'üîÑ Refreshing call history from Redshift...');
            loadHistoryFromRedshift();
        });
        document.getElementById('exportAllHistory').addEventListener('click', exportAllHistory);

        // Initialize
        console.log('üöÄ Initializing application...');
        loadHCPs();
        updateCallLogTable();
        loadHistoryFromRedshift().then(historyCount => {
            console.log('ü§ñ Nova Sonic Voice Test Loaded');
            console.log('API Base:', API_BASE);
            console.log('Mode: Voice (Nova Sonic)');
            console.log(`üìö Loaded ${historyCount} previous call logs from Redshift`);
        });
        console.log('üíæ Export button:', exportJsonBtn ? 'Found' : 'NOT FOUND');
        console.log('üóëÔ∏è  Clear history button:', document.getElementById('clearHistory') ? 'Found' : 'NOT FOUND');
    </script>
</body>
</html>

